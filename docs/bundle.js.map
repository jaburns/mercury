{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/grid.ts","webpack:///./src/main.ts","webpack:///./src/vector-caves.ts","webpack:///./src/automaton.ts","webpack:///./src/prng.ts","webpack:///./src/findContours.ts","webpack:///./src/math.ts","webpack:///./src/smoothCurve.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","WriteGrid","width","height","this","vals","Array","write","x","y","val","at","copyFrom","grid","safeOutOfBounds","oobValue","GridTool","find","test","forEach","fn","map","result","postInitters","vector-caves","initPost","window","grid_1","automaton_1","findContours_1","smoothCurve_1","math_1","floodFill","replace","count","tile","events","listener","ctx","document","getElementById","getContext","seedSlider","popSlider","genSlider","insuranceSlider","curvinessSlider","ctx2","ctx3","ctx4","ctx5","ctx6","ctx7","ctx8","update","runCellularAutomaton","parseInt","parseFloat","fillStyle","fillRect","coloredGrid","bigColor","color","largestColor","largestRegion","pos","size","colorGridRegions","gridColorForNumber","filledMap","edgeMarkedMap","markEdges","kind","degs","Math","cos","PI","sin","hx","round","hy","toString","gridColorForNormal","normal","contours","findContours","walkMap","WalkedStatus","WalkedImportant","Walked","outerIndex","area","RectTool","findBounds","sort","a","b","strokeStyle","i_1","length","j","beginPath","moveTo","lineTo","stroke","smoothContours","smoothCurve","i_2","topLeftPtI","len","topLeftPt","arc","splice","i_3","fill","e","prng_1","getNeighborhood","nx","ny","seed","population","birth","survival","iterations","buffer","rand","nextRandom01","neighbors","M","prevRandom01","floor","u","spaceInsurance","_","Unwalked","iter","newContour","findOneContour","push","bestCandidate","prev","candidates","minVal","minI","abs","smallestDifferenceRadians","freshStart","findFreshContour","points","lastCan","dx","dy","lastStatus","newStatus","V2","add","plus","minus","sqrt","scaled","xmax","xmin","ymax","ymin","pts","Infinity","input","resolution","curviness","curr","next","lenA","lenB","midA","midB","midDiff","diffA","diffB","pt","controlA","controlB","inc","newVal"],"mappings":"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","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","export interface Grid<T> {\r\n    readonly width: number;\r\n    readonly height: number;\r\n    at(x: number, y: number): T;\r\n}\r\n\r\nexport type GridCallback<T> = (x: number, y: number, val: T) => void;\r\nexport type GridMapper<T,U> = (x: number, y: number, val: T) => U;\r\n\r\nexport class WriteGrid<T> implements Grid<T> {\r\n    public readonly width: number;\r\n    public readonly height: number;\r\n\r\n    private vals: T[];\r\n\r\n    constructor(width: number, height: number) {\r\n        this.width = width;\r\n        this.height = height;\r\n        this.vals = new Array(width * height);\r\n    }\r\n\r\n    write(x: number, y: number, val: T): void {\r\n        this.vals[x + y*this.width] = val;\r\n    }\r\n\r\n    at(x: number, y: number): T {\r\n        return this.vals[x + y*this.width];\r\n    }\r\n\r\n    copyFrom(grid: Grid<T>): void {\r\n        for (let x = 0; x < this.width && x < grid.width; ++x) {\r\n            for (let y = 0; y < this.height && y < grid.height; ++y) {\r\n                this.write(x, y, grid.at(x, y));\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport const safeOutOfBounds = <T>(grid: Grid<T>, oobValue: T): Grid<T> => ({\r\n    width: grid.width,\r\n    height: grid.height,\r\n    at: (x, y) => x < 0 || y < 0 || x >= grid.width || y >= grid.width ? oobValue : grid.at(x, y)\r\n});\r\n\r\nexport const GridTool = {\r\n    find: <T>(grid: Grid<T>, test: GridMapper<T, boolean>): { x: number, y: number } | null => {\r\n        for (let x = 0; x < grid.width; ++x) {\r\n            for (let y = 0; y < grid.height; ++y) {\r\n                if (test(x, y, grid.at(x, y))) {\r\n                    return { x, y };\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    },\r\n\r\n    forEach: <T>(grid: Grid<T>, fn: GridCallback<T>): void => {\r\n        for (let x = 0; x < grid.width; ++x) {\r\n            for (let y = 0; y < grid.height; ++y) {\r\n                fn(x, y, grid.at(x, y));\r\n            }\r\n        }\r\n    },\r\n\r\n    map: <T, U>(grid: Grid<T>, fn: GridMapper<T, U>): WriteGrid<U> => {\r\n        const result = new WriteGrid<U>(grid.width, grid.height);\r\n\r\n        for (let x = 0; x < grid.width; ++x) {\r\n            for (let y = 0; y < grid.height; ++y) {\r\n                result.write(x, y, fn(x, y, grid.at(x, y)));\r\n            }\r\n        }\r\n\r\n        return result;\r\n    },\r\n};","import { initPost as initPost_vectorCaves } from './vector-caves';\r\n\r\nconst postInitters: {[key: string]: () => void} = {\r\n    'vector-caves': initPost_vectorCaves\r\n};\r\n\r\n(window as any).initPost = (name: string): void =>\r\n    postInitters[name]();","import { WriteGrid, GridTool } from './grid';\r\nimport { runCellularAutomaton } from './automaton';\r\nimport { markEdges, findContours, WalkedStatus } from './findContours';\r\nimport { smoothCurve } from './smoothCurve';\r\nimport { Vec2, findBounds, RectTool } from './math';\r\n\r\nconst floodFill = (grid: WriteGrid<number>, x: number, y: number, replace: number, value: number, count: number): number => {\r\n    if (x < 0 || y < 0) return count;\r\n    if (x >= grid.width || y >= grid.height) return count;\r\n\r\n    const tile = grid.at(x, y);\r\n\r\n    if (tile === value) return count;\r\n    if (tile !== replace) return count;\r\n\r\n    grid.write(x, y, value);\r\n    count++;\r\n\r\n    count = floodFill(grid, x - 1, y, replace, value, count);\r\n    count = floodFill(grid, x + 1, y, replace, value, count);\r\n    count = floodFill(grid, x, y - 1, replace, value, count);\r\n    count = floodFill(grid, x, y + 1, replace, value, count);\r\n    return count;\r\n};\r\n\r\nconst colorGridRegions = (grid: WriteGrid<number>): number => {\r\n    let color = 1;\r\n    let largestColor = -1;\r\n    let largestRegion = 0;\r\n\r\n    while (true) {\r\n        const pos = GridTool.find(grid, (x, y, val) => val === 0);\r\n        if (pos === null) return largestColor;\r\n\r\n        const size = floodFill(grid, pos.x, pos.y, 0, color, 0);\r\n\r\n        if (size > largestRegion) {\r\n            largestRegion = size;\r\n            largestColor = color;\r\n        }\r\n\r\n        color++;\r\n    }\r\n};\r\n\r\nconst gridColorForNumber = (n: number): string => {\r\n    if (n < 0) return '#000';\r\n    switch (n % 6) {\r\n        case  0: return '#F00';\r\n        case  1: return '#0F0';\r\n        case  2: return '#00F';\r\n        case  3: return '#0FF';\r\n        case  4: return '#F0F';\r\n        case  5: return '#FF0';\r\n    }\r\n    return '';\r\n};\r\n\r\nconst gridColorForNormal = (degs: number): string => {\r\n    const x = Math.cos(degs * Math.PI / 180);\r\n    const y = Math.sin(degs * Math.PI / 180);\r\n\r\n    const hx = Math.round(15 * (0.5*x + 0.5));\r\n    const hy = Math.round(15 * (0.5*y + 0.5));\r\n\r\n    const result = '#' + hx.toString(16) + hy.toString(16) + 'f';\r\n\r\n    return result;\r\n};\r\n\r\nconst multibind = (objs: any[], events: string[], listener: Function): void => {\r\n    objs.forEach(o => {\r\n        events.forEach(e => {\r\n            o[e] = listener;\r\n        });\r\n    });\r\n};\r\n\r\nexport const initPost = () :void => {\r\n    const firstCanvas = document.getElementById('first-canvas') as HTMLCanvasElement;\r\n    const ctx = firstCanvas.getContext('2d') as CanvasRenderingContext2D;\r\n\r\n    const seedSlider = document.getElementById('seed-slider') as HTMLInputElement;\r\n    const popSlider = document.getElementById('pop-slider') as HTMLInputElement;\r\n    const genSlider = document.getElementById('gen-slider') as HTMLInputElement;\r\n    const insuranceSlider = document.getElementById('insurance-slider') as HTMLInputElement;\r\n    const curvinessSlider = document.getElementById('curviness-slider') as HTMLInputElement;\r\n\r\n    const secondCanvas = document.getElementById('second-canvas') as HTMLCanvasElement;\r\n    const ctx2 = secondCanvas.getContext('2d') as CanvasRenderingContext2D;\r\n\r\n    const thirdCanvas = document.getElementById('third-canvas') as HTMLCanvasElement;\r\n    const ctx3 = thirdCanvas.getContext('2d') as CanvasRenderingContext2D;\r\n\r\n    const fourthCanvas = document.getElementById('fourth-canvas') as HTMLCanvasElement;\r\n    const ctx4 = fourthCanvas.getContext('2d') as CanvasRenderingContext2D;\r\n\r\n    const fifthCanvas = document.getElementById('fifth-canvas') as HTMLCanvasElement;\r\n    const ctx5 = fifthCanvas.getContext('2d') as CanvasRenderingContext2D;\r\n\r\n    const sixthCanvas = document.getElementById('sixth-canvas') as HTMLCanvasElement;\r\n    const ctx6 = sixthCanvas.getContext('2d') as CanvasRenderingContext2D;\r\n\r\n    const seventhCanvas = document.getElementById('seventh-canvas') as HTMLCanvasElement;\r\n    const ctx7 = seventhCanvas.getContext('2d') as CanvasRenderingContext2D;\r\n\r\n    const eighthCanvas = document.getElementById('eighth-canvas') as HTMLCanvasElement;\r\n    const ctx8 = eighthCanvas.getContext('2d') as CanvasRenderingContext2D;\r\n\r\n    const update = () :void => {\r\n        const grid = runCellularAutomaton(\r\n            75, 75,\r\n            parseInt(seedSlider.value),\r\n            parseFloat(popSlider.value),\r\n            5, 4,\r\n            parseInt(genSlider.value)\r\n        );\r\n\r\n        GridTool.forEach(grid, (x, y, val) => {\r\n            ctx.fillStyle = val ? '#000' : '#FFF';\r\n            ctx.fillRect(4*x, 4*y, 4, 4);\r\n        });\r\n\r\n        const coloredGrid = GridTool.map(grid, (x, y, val) => val ? -1 : 0);\r\n        const bigColor = colorGridRegions(coloredGrid);\r\n\r\n        GridTool.forEach(coloredGrid, (x, y, val) => {\r\n            ctx2.fillStyle = gridColorForNumber(val);\r\n            ctx2.fillRect(4*x, 4*y, 4, 4);\r\n        });\r\n\r\n        const filledMap = GridTool.map(coloredGrid, (x, y, val) => val !== bigColor);\r\n\r\n        GridTool.forEach(filledMap, (x, y, val) => {\r\n            ctx3.fillStyle = val ? '#000' : '#FFF';\r\n            ctx3.fillRect(4*x, 4*y, 4, 4);\r\n        });\r\n\r\n        const edgeMarkedMap = markEdges(filledMap);\r\n\r\n        GridTool.forEach(edgeMarkedMap, (x, y, val) => {\r\n            ctx4.fillStyle = val.kind === 'edge' ? gridColorForNormal(val.normal) : val.kind === 'air' ? '#655' : '#77f';\r\n            ctx4.fillRect(4*x, 4*y, 4, 4);\r\n        });\r\n\r\n        const contours = findContours(edgeMarkedMap, parseInt(insuranceSlider.value) as any);\r\n\r\n        GridTool.forEach(contours.walkMap, (x, y, val) => {\r\n            ctx5.fillStyle = val === WalkedStatus.WalkedImportant ? '#fff' : val === WalkedStatus.Walked ? '#333' : '#000';\r\n            ctx5.fillRect(4*x, 4*y, 4, 4);\r\n\r\n            ctx6.fillStyle = val === WalkedStatus.WalkedImportant ? '#333' : '#000';\r\n            ctx6.fillRect(9*x, 9*y, 9, 9);\r\n        });\r\n\r\n        const outerIndex = contours.contours\r\n            .map((c, i) => ({ i, area: RectTool.area(findBounds(c)) }))\r\n            .sort((a, b) => b.area - a.area)\r\n            [0].i;\r\n\r\n        contours.contours.forEach((c, i) => {\r\n            ctx6.strokeStyle = i === outerIndex ? '#f00' : '#933';\r\n\r\n            for (let i = 0; i < c.length; ++i) {\r\n                const j = (i + 1) % c.length;\r\n                const a = { x: 9 * contours.walkMap.width * c[i].x, y: 9 * contours.walkMap.height * c[i].y };\r\n                const b = { x: 9 * contours.walkMap.width * c[j].x, y: 9 * contours.walkMap.height * c[j].y };\r\n                \r\n                ctx6.beginPath();\r\n                ctx6.moveTo(9 * contours.walkMap.width / 2 + a.x, 9 * contours.walkMap.height / 2 + a.y);\r\n                ctx6.lineTo(9 * contours.walkMap.width / 2 + b.x, 9 * contours.walkMap.height / 2 + b.y);\r\n                // TODO closePath\r\n                ctx6.stroke();\r\n            }\r\n        });\r\n\r\n        const smoothContours = contours.contours.map(x => smoothCurve(x, 20, 2 * parseFloat(curvinessSlider.value) / 100));\r\n\r\n        ctx7.strokeStyle = '#0f0';\r\n        ctx7.fillStyle = '#000';\r\n        ctx7.fillRect(0, 0, 675, 675);\r\n\r\n        smoothContours.forEach((c, i) => {\r\n            ctx7.strokeStyle = i === outerIndex ? '#0f0' : '#393';\r\n\r\n            for (let i = 0; i < c.length; ++i) {\r\n                const j = (i + 1) % c.length;\r\n                const a = { x: 9 * contours.walkMap.width * c[i].x, y: 9 * contours.walkMap.height * c[i].y };\r\n                const b = { x: 9 * contours.walkMap.width * c[j].x, y: 9 * contours.walkMap.height * c[j].y };\r\n                \r\n                ctx7.beginPath();\r\n                ctx7.moveTo(9 * contours.walkMap.width / 2 + a.x, 9 * contours.walkMap.height / 2 + a.y);\r\n                ctx7.lineTo(9 * contours.walkMap.width / 2 + b.x, 9 * contours.walkMap.height / 2 + b.y);\r\n                // TODO closePath\r\n                ctx7.stroke();\r\n            }\r\n        });\r\n\r\n        // TODO find closest point to the actual OOB point we're making the seam to.\r\n        const mostTopLeft = (pts: Vec2[]): number =>\r\n            pts.map((p, i) => ({ i, len: (p.x+0.5)*(p.x+0.5) + (p.y+0.5)*(p.y+0.5) }))\r\n                .sort((a, b) => a.len - b.len)\r\n                [0].i;\r\n\r\n        const topLeftPtI = mostTopLeft(smoothContours[outerIndex]);\r\n        const topLeftPt = smoothContours[outerIndex][topLeftPtI];\r\n\r\n        ctx7.strokeStyle = '#0f0';\r\n        ctx7.beginPath();\r\n        ctx7.moveTo(\r\n            9 * contours.walkMap.width / 2 + 9 * contours.walkMap.width * topLeftPt.x,\r\n            9 * contours.walkMap.height / 2 + 9 * contours.walkMap.height * topLeftPt.y,\r\n        );\r\n        ctx7.lineTo(\r\n            -9 * contours.walkMap.width / 2,\r\n            -9 * contours.walkMap.height / 2\r\n        );\r\n        ctx7.stroke();\r\n\r\n        ctx7.strokeStyle = '#9f9';\r\n        ctx7.beginPath();\r\n        ctx7.arc(\r\n            9 * contours.walkMap.width / 2 + 9 * contours.walkMap.width * topLeftPt.x,\r\n            9 * contours.walkMap.height / 2 + 9 * contours.walkMap.height * topLeftPt.y,\r\n            5, 0, 2*Math.PI);\r\n        ctx7.stroke();\r\n\r\n        // =--------------------------------------------\r\n\r\n        smoothContours[outerIndex].splice(topLeftPtI, 0,\r\n            topLeftPt,\r\n            {x: -1.5, y: -1.5},\r\n            {x: -1.5, y:  1.5},\r\n            {x:  1.5, y:  1.5},\r\n            {x:  1.5, y: -1.5},\r\n            {x: -1.5, y: -1.5});\r\n\r\n        // =--------------------------------------------\r\n\r\n        ctx8.fillStyle = '#000';\r\n        ctx8.fillRect(0, 0, 675, 675);\r\n        //ctx8.strokeStyle = '';\r\n\r\n\r\n        smoothContours.forEach((c, i) => {\r\n            ctx8.fillStyle = i === outerIndex ? '#0f0' : '#393';\r\n\r\n            ctx8.beginPath();\r\n            const a = { x: 9 * contours.walkMap.width * c[i].x, y: 9 * contours.walkMap.height * c[i].y };\r\n            ctx8.moveTo(9 * contours.walkMap.width / 2 + a.x, 9 * contours.walkMap.height / 2 + a.y);\r\n\r\n            for (let i = 1; i < c.length; ++i) {\r\n                const b = { x: 9 * contours.walkMap.width * c[i].x, y: 9 * contours.walkMap.height * c[i].y };\r\n                ctx8.lineTo(9 * contours.walkMap.width / 2 + b.x, 9 * contours.walkMap.height / 2 + b.y);\r\n            }\r\n\r\n            ctx8.fill();\r\n        });\r\n    };\r\n\r\n    multibind(\r\n        [popSlider, genSlider, seedSlider, insuranceSlider, curvinessSlider],\r\n        ['oninput', 'onchange'],\r\n        update\r\n    );\r\n    update();\r\n};","import { nextRandom01 } from './prng';\r\nimport { WriteGrid, Grid } from './grid';\r\n\r\nconst getNeighborhood = (map: Grid<boolean>, x: number, y: number): number => {\r\n    let result: number = 0;\r\n\r\n    for (let nx = x-1; nx <= x+1; ++nx) {\r\n        for (let ny = y-1; ny <= y+1; ++ny) {\r\n            if (nx == x && ny == y) continue;\r\n            if (nx < 1 || ny < 1 || nx >= map.width-1 || ny >= map.height-1) result++;\r\n            else result += map.at(nx,ny) ? 1 : 0;\r\n        }\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\nexport const runCellularAutomaton = (width: number, height: number, seed: number, population: number, birth: number, survival: number, iterations: number): Grid<boolean> => {\r\n    const result = new WriteGrid<boolean>(width, height);\r\n    const buffer = new WriteGrid<boolean>(width, height);\r\n    let rand = nextRandom01(seed / 101);\r\n\r\n    for (let x = 0; x < width; ++x) {\r\n        for (let y = 0; y < height; ++y) {\r\n            const fill = x === 0 || y === 0 || x === width-1 || y === height-1 || rand < population;\r\n            result.write(x, y, fill);\r\n            buffer.write(x, y, fill);\r\n\r\n            rand = nextRandom01(rand);\r\n        }\r\n    }\r\n\r\n    for (let i = 0; i < iterations; ++i) {\r\n        for (let x = 1; x < width-1; ++x) {\r\n            for (let y = 1; y < height-1; ++y) {\r\n                const neighbors = getNeighborhood(result, x, y);\r\n                buffer.write(x, y, neighbors >= (result.at(x, y) ? survival : birth));\r\n            }\r\n        }\r\n        result.copyFrom(buffer);\r\n    }\r\n\r\n    return result;\r\n}","// https://en.wikipedia.org/wiki/Linear_congruential_generator\r\n\r\nconst M = 4294967296;\r\nconst A = 1664525;\r\nconst C = 1013904223;\r\n\r\nexport const nextRandom01 = (prevRandom01: number): number => \r\n    ((A * Math.floor(prevRandom01 * M) + C) % M) / M;","import { Grid, WriteGrid, GridTool, safeOutOfBounds } from './grid';\r\nimport { Vec2, smallestDifferenceRadians } from './math';\r\n\r\nexport interface EdgeMarkedMapTile {\r\n    kind: 'air' | 'dirt' | 'edge',\r\n    normal: number,\r\n}\r\n\r\nexport const markEdges = (grid: Grid<boolean>): WriteGrid<EdgeMarkedMapTile> => {\r\n    const result = GridTool.map(grid, (x, y, val): EdgeMarkedMapTile => \r\n        ({ kind: val ? 'dirt' : 'air', normal: 0 }));\r\n\r\n    for (let x = 0; x < grid.width; x++) {\r\n        for (let y = 0; y < grid.height; y++) {\r\n            if (!grid.at(x, y)) continue;\r\n\r\n            const l = x > 0               && !grid.at(x-1, y);\r\n            const r = x < grid.width - 2  && !grid.at(x+1, y);\r\n            const u = y > 0               && !grid.at(x, y-1);\r\n            const d = y < grid.height - 2 && !grid.at(x, y+1);\r\n\r\n            if (!l && !r && !u && !d) continue;\r\n\r\n            const normal = r && d ? 45 :\r\n                d && l ?  135 :\r\n                l && u ? -135 :\r\n                u && r ?  -45 :\r\n                r ? 0 :\r\n                d ? 90 :\r\n                l ? 180 :\r\n                -90;\r\n\r\n            result.write(x, y, { kind: 'edge', normal });\r\n        }\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\nexport enum WalkedStatus {\r\n    Unwalked,\r\n    Walked,\r\n    WalkedImportant,\r\n}\r\n\r\ninterface WalkCandidate {\r\n    dx: number,\r\n    dy: number,\r\n    normal: number,\r\n}\r\n\r\ninterface GridPoint {\r\n    x: number,\r\n    y: number,\r\n}\r\n\r\nexport interface FindContoursResult {\r\n    contours: Vec2[][],\r\n    walkMap: WriteGrid<WalkedStatus>,\r\n}\r\n\r\nexport const findContours = (grid: Grid<EdgeMarkedMapTile>, spaceInsurance: 0 | 1 | 2): FindContoursResult => {\r\n    const MAX_ITER = 100;\r\n    const walkMap = GridTool.map(new WriteGrid<WalkedStatus>(grid.width, grid.height), _ => WalkedStatus.Unwalked);\r\n    const contours: Vec2[][] = [];\r\n\r\n    let iter = 0;\r\n    let newContour: Vec2[] | null = null;\r\n\r\n    do {\r\n        newContour = findOneContour(walkMap, grid, spaceInsurance);\r\n        if (newContour !== null && newContour.length > 2) {\r\n            contours.push(newContour);\r\n        }\r\n    } while (newContour != null && iter++ < MAX_ITER);\r\n\r\n    return { contours, walkMap };\r\n}\r\n\r\n// @ts-ignore\r\nconst findFreshContour = (walkMap: Grid<WalkedStatus>, grid: Grid<EdgeMarkedMapTile>): GridPoint | null => {\r\n    for (let x = 0; x < grid.width; x++) {\r\n        for (let y = 0; y < grid.height; y++) {\r\n            if (grid.at(x, y).kind === 'edge' && walkMap.at(x, y) === WalkedStatus.Unwalked) {\r\n                return { x, y };\r\n            }\r\n        }\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\nconst bestCandidate = (prev: WalkCandidate, candidates: WalkCandidate[]): WalkCandidate => {\r\n    let minVal = 100;\r\n    let minI = 0;\r\n\r\n    for (let i = 0; i < candidates.length; ++i) {\r\n        const c = candidates[i];\r\n        const d = Math.abs(smallestDifferenceRadians(\r\n            c.normal * Math.PI / 180,\r\n            prev.normal * Math.PI / 180\r\n        ));\r\n\r\n        if (d < minVal) {\r\n            minVal = d;\r\n            minI = i;\r\n        }\r\n    }\r\n\r\n    return candidates[minI];\r\n};\r\n\r\nconst findOneContour = (walkMap: WriteGrid<WalkedStatus>, grid: Grid<EdgeMarkedMapTile>, spaceInsurance: 0 | 1 | 2): Vec2[] | null => {\r\n    const MAX_ITER = 5000;\r\n\r\n    const freshStart = findFreshContour(walkMap, grid);\r\n    if (freshStart === null) {\r\n        return null;\r\n    }\r\n\r\n    grid = safeOutOfBounds(grid, {kind: 'dirt', normal: 0} as EdgeMarkedMapTile);\r\n\r\n    const points: Vec2[] = [];\r\n    let x = freshStart.x;\r\n    let y = freshStart.y;\r\n\r\n    let iter = 0;\r\n    let lastCan: WalkCandidate = { dx: 0, dy: 0, normal: 0 };\r\n    let lastStatus = WalkedStatus.Walked;\r\n    let candidates: WalkCandidate[] = [];\r\n\r\n    do {\r\n        candidates = [];\r\n\r\n        for (let dx = -1; dx <= 1; dx++) {\r\n            for (let dy = -1; dy <= 1; dy++) {\r\n                if (dx === 0 && dy === 0) continue;\r\n                if (grid.at(x+dx, y+dy).kind === 'edge'\r\n                && walkMap.at(x+dx, y+dy) === WalkedStatus.Unwalked) {\r\n                    candidates.push({dx, dy, normal: grid.at(x+dx, y+dy).normal});\r\n                }\r\n            }\r\n        }\r\n\r\n        if (candidates.length > 0) {\r\n            const c = bestCandidate(lastCan, candidates);\r\n            x += c.dx;\r\n            y += c.dy;\r\n\r\n            let newStatus = WalkedStatus.Walked;\r\n            if (c.normal !== lastCan.normal) {\r\n                let important;\r\n                if (spaceInsurance === 0) {\r\n                    important = true;\r\n                } else if (spaceInsurance === 1) {\r\n                    important = c.dx != 0 && c.dy != 0 || lastStatus != WalkedStatus.WalkedImportant;\r\n                } else {\r\n                    important = lastStatus != WalkedStatus.WalkedImportant;\r\n                }\r\n\r\n                if (important) {\r\n                    newStatus = WalkedStatus.WalkedImportant;\r\n                }\r\n            }\r\n\r\n            if (newStatus === WalkedStatus.WalkedImportant) {\r\n                points.push({\r\n                    x: (x + 0.5)/grid.width - 0.5,\r\n                    y: (y + 0.5)/grid.height - 0.5,\r\n                });\r\n            }\r\n\r\n            walkMap.write(x, y, newStatus);\r\n            lastStatus = newStatus;\r\n            lastCan = c;\r\n        }\r\n    }\r\n    while (candidates.length > 0 && iter++ < MAX_ITER);\r\n\r\n    return points;\r\n};","export interface Vec2 {\r\n    x: number,\r\n    y: number,\r\n}\r\n\r\nexport interface Rect {\r\n    xmin: number,\r\n    ymin: number,\r\n    xmax: number,\r\n    ymax: number,\r\n}\r\n\r\nexport const V2 = {\r\n    add: (a: Vec2, b: Vec2): void => {\r\n        a.x += b.x;\r\n        a.y += b.y;\r\n    },\r\n\r\n    plus: (a: Vec2, b: Vec2): Vec2 => ({\r\n        x: a.x + b.x,\r\n        y: a.y + b.y,\r\n    }),\r\n\r\n    minus: (a: Vec2, b: Vec2): Vec2 => ({\r\n        x: a.x - b.x,\r\n        y: a.y - b.y,\r\n    }),\r\n\r\n    length: (a: Vec2): number =>\r\n        Math.sqrt(a.x*a.x + a.y*a.y),\r\n    \r\n    scaled: (a: Vec2, s: number): Vec2 => ({\r\n        x: s * a.x,\r\n        y: s * a.y,\r\n    }),\r\n};\r\n\r\nexport const RectTool = {\r\n    area: (r: Rect): number =>\r\n        (r.xmax - r.xmin) * (r.ymax - r.ymin),\r\n};\r\n\r\nexport const smallestDifferenceRadians = (a: number, b: number): number => {\r\n    a %= 2 * Math.PI;\r\n    b %= 2 * Math.PI;\r\n\r\n    if (Math.abs(a - b) > Math.PI) {\r\n        if (a > 0) a -= 2 * Math.PI;\r\n        else a += 2 * Math.PI;\r\n    }\r\n\r\n    return a - b;\r\n};\r\n\r\nexport const findBounds = (pts: Vec2[]): Rect => {\r\n    const result: Rect = { xmin: Infinity, ymin: Infinity, xmax: -Infinity, ymax: -Infinity };\r\n\r\n    pts.forEach(p => {\r\n        if (p.x < result.xmin) result.xmin = p.x;\r\n        if (p.y < result.ymin) result.ymin = p.y;\r\n        if (p.x > result.xmax) result.xmax = p.x;\r\n        if (p.y > result.ymax) result.ymax = p.y;\r\n    });\r\n\r\n    return result;\r\n};","import { Vec2, V2 } from \"./math\";\r\n\r\ninterface Pt {\r\n    pt: Vec2,\r\n    controlA: Vec2,\r\n    controlB: Vec2,\r\n}\r\n\r\nexport const smoothCurve = (input: Vec2[], resolution: number, curviness: number): Vec2[] => {\r\n    const pts: Pt[] = [];\r\n\r\n    if (resolution < 1) resolution = 1;\r\n\r\n    for (let i = 0; i < input.length; ++i) {\r\n        const prev = input[i == 0 ? input.length-1 : i-1];\r\n        const curr = input[i];\r\n        const next = input[(i + 1) % input.length];\r\n\r\n        const lenA = V2.length(V2.minus(prev, curr));\r\n        const lenB = V2.length(V2.minus(curr, next));\r\n\r\n        const midA = V2.scaled(V2.plus(prev, curr), 0.5);\r\n        const midB = V2.scaled(V2.plus(curr, next), 0.5);\r\n        const midDiff = V2.scaled(V2.minus(midA, midB), curviness);\r\n\r\n        const diffA = V2.scaled(midDiff,  lenA / (lenA + lenB));\r\n        const diffB = V2.scaled(midDiff, -lenB / (lenA + lenB));\r\n\r\n        pts.push({\r\n            pt: curr,\r\n            controlA: V2.plus(curr, diffA),\r\n            controlB: V2.plus(curr, diffB),\r\n        });\r\n    }\r\n\r\n    const inc = 1 / resolution;\r\n\r\n    const result: Vec2[] = [];\r\n    for (let i = 0; i < pts.length; ++i) {\r\n        const curr = pts[i];\r\n        const next = pts[(i + 1) % pts.length];\r\n\r\n        for (let t = 0; t < 1; t += inc) {\r\n            let newVal: Vec2 = { x: 0, y: 0 };\r\n\r\n            V2.add(newVal, V2.scaled(curr.pt       , (1-t)*(1-t)*(1-t)));\r\n            V2.add(newVal, V2.scaled(curr.controlB , 3*(1-t)*(1-t)*t));\r\n            V2.add(newVal, V2.scaled(next.controlA , 3*(1-t)*t*t));\r\n            V2.add(newVal, V2.scaled(next.pt       , t*t*t));\r\n\r\n            result.push(newVal);\r\n        }\r\n    }\r\n\r\n    return result;\r\n};"],"sourceRoot":""}