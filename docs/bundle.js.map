{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/grid.ts","webpack:///./src/main.ts","webpack:///./src/vector-caves.ts","webpack:///./src/automaton.ts","webpack:///./src/prng.ts","webpack:///./src/findContours.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","WriteGrid","width","height","this","vals","Array","write","x","y","val","at","copyFrom","grid","GridTool","find","test","forEach","fn","map","result","postInitters","vector-caves","initPost","window","grid_1","automaton_1","findContours_1","floodFill","replace","count","tile","events","listener","ctx","document","getElementById","getContext","seedSlider","popSlider","genSlider","ctx2","ctx3","ctx4","update","runCellularAutomaton","parseInt","parseFloat","fillStyle","fillRect","coloredGrid","bigColor","color","largestColor","largestRegion","pos","size","colorGridRegions","gridColorForNumber","filledMap","edgeMarkedMap","markEdges","kind","degs","Math","cos","PI","sin","hx","round","hy","toString","gridColorForNormal","normal","e","prng_1","getNeighborhood","nx","ny","seed","population","birth","survival","iterations","buffer","rand","nextRandom01","fill","neighbors","M","prevRandom01","floor","WalkedStatus","u"],"mappings":"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","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","export interface Grid<T> {\r\n    readonly width: number;\r\n    readonly height: number;\r\n    at(x: number, y: number): T;\r\n}\r\n\r\nexport type GridCallback<T> = (x: number, y: number, val: T) => void;\r\nexport type GridMapper<T,U> = (x: number, y: number, val: T) => U;\r\n\r\nexport class WriteGrid<T> implements Grid<T> {\r\n    public readonly width: number;\r\n    public readonly height: number;\r\n\r\n    private vals: T[];\r\n\r\n    constructor(width: number, height: number) {\r\n        this.width = width;\r\n        this.height = height;\r\n        this.vals = new Array(width * height);\r\n    }\r\n\r\n    write(x: number, y: number, val: T): void {\r\n        this.vals[x + y*this.width] = val;\r\n    }\r\n\r\n    at(x: number, y: number): T {\r\n        return this.vals[x + y*this.width];\r\n    }\r\n\r\n    copyFrom(grid: Grid<T>): void {\r\n        for (let x = 0; x < this.width && x < grid.width; ++x) {\r\n            for (let y = 0; y < this.height && y < grid.height; ++y) {\r\n                this.write(x, y, grid.at(x, y));\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport const GridTool = {\r\n    find: <T>(grid: Grid<T>, test: GridMapper<T, boolean>): { x: number, y: number } | null => {\r\n        for (let x = 0; x < grid.width; ++x) {\r\n            for (let y = 0; y < grid.height; ++y) {\r\n                if (test(x, y, grid.at(x, y))) {\r\n                    return { x, y };\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    },\r\n\r\n    forEach: <T>(grid: Grid<T>, fn: GridCallback<T>): void => {\r\n        for (let x = 0; x < grid.width; ++x) {\r\n            for (let y = 0; y < grid.height; ++y) {\r\n                fn(x, y, grid.at(x, y));\r\n            }\r\n        }\r\n    },\r\n\r\n    map: <T, U>(grid: Grid<T>, fn: GridMapper<T, U>): WriteGrid<U> => {\r\n        const result = new WriteGrid<U>(grid.width, grid.height);\r\n\r\n        for (let x = 0; x < grid.width; ++x) {\r\n            for (let y = 0; y < grid.height; ++y) {\r\n                result.write(x, y, fn(x, y, grid.at(x, y)));\r\n            }\r\n        }\r\n\r\n        return result;\r\n    },\r\n};","import { initPost as initPost_vectorCaves } from './vector-caves';\r\n\r\nconst postInitters: {[key: string]: () => void} = {\r\n    'vector-caves': initPost_vectorCaves\r\n};\r\n\r\n(window as any).initPost = (name: string): void =>\r\n    postInitters[name]();","import { WriteGrid, GridTool } from './grid';\r\nimport { runCellularAutomaton } from './automaton';\r\nimport { markEdges } from './findContours';\r\n\r\nconst floodFill = (grid: WriteGrid<number>, x: number, y: number, replace: number, value: number, count: number): number => {\r\n    if (x < 0 || y < 0) return count;\r\n    if (x >= grid.width || y >= grid.height) return count;\r\n\r\n    const tile = grid.at(x, y);\r\n\r\n    if (tile === value) return count;\r\n    if (tile !== replace) return count;\r\n\r\n    grid.write(x, y, value);\r\n    count++;\r\n\r\n    count = floodFill(grid, x - 1, y, replace, value, count);\r\n    count = floodFill(grid, x + 1, y, replace, value, count);\r\n    count = floodFill(grid, x, y - 1, replace, value, count);\r\n    count = floodFill(grid, x, y + 1, replace, value, count);\r\n    return count;\r\n};\r\n\r\nconst colorGridRegions = (grid: WriteGrid<number>): number => {\r\n    let color = 1;\r\n    let largestColor = -1;\r\n    let largestRegion = 0;\r\n\r\n    while (true) {\r\n        const pos = GridTool.find(grid, (x, y, val) => val === 0);\r\n        if (pos === null) return largestColor;\r\n\r\n        const size = floodFill(grid, pos.x, pos.y, 0, color, 0);\r\n\r\n        if (size > largestRegion) {\r\n            largestRegion = size;\r\n            largestColor = color;\r\n        }\r\n\r\n        color++;\r\n    }\r\n};\r\n\r\nconst gridColorForNumber = (n: number): string => {\r\n    if (n < 0) return '#000';\r\n    switch (n % 6) {\r\n        case  0: return '#F00';\r\n        case  1: return '#0F0';\r\n        case  2: return '#00F';\r\n        case  3: return '#0FF';\r\n        case  4: return '#F0F';\r\n        case  5: return '#FF0';\r\n    }\r\n    return '';\r\n};\r\n\r\nconst gridColorForNormal = (degs: number): string => {\r\n    const x = Math.cos(degs * Math.PI / 180);\r\n    const y = Math.sin(degs * Math.PI / 180);\r\n\r\n    const hx = Math.round(15 * (0.5*x + 0.5));\r\n    const hy = Math.round(15 * (0.5*y + 0.5));\r\n\r\n    const result = '#' + hx.toString(16) + hy.toString(16) + 'f';\r\n\r\n    return result;\r\n};\r\n\r\nconst multibind = (objs: any[], events: string[], listener: Function): void => {\r\n    objs.forEach(o => {\r\n        events.forEach(e => {\r\n            o[e] = listener;\r\n        });\r\n    });\r\n};\r\n\r\nexport const initPost = () :void => {\r\n    const firstCanvas = document.getElementById('first-canvas') as HTMLCanvasElement;\r\n    const ctx = firstCanvas.getContext('2d') as CanvasRenderingContext2D;\r\n\r\n    const seedSlider = document.getElementById('seed-slider') as HTMLInputElement;\r\n    const popSlider = document.getElementById('pop-slider') as HTMLInputElement;\r\n    const genSlider = document.getElementById('gen-slider') as HTMLInputElement;\r\n\r\n    const secondCanvas = document.getElementById('second-canvas') as HTMLCanvasElement;\r\n    const ctx2 = secondCanvas.getContext('2d') as CanvasRenderingContext2D;\r\n\r\n    const thirdCanvas = document.getElementById('third-canvas') as HTMLCanvasElement;\r\n    const ctx3 = thirdCanvas.getContext('2d') as CanvasRenderingContext2D;\r\n\r\n    const fourthCanvas = document.getElementById('fourth-canvas') as HTMLCanvasElement;\r\n    const ctx4 = fourthCanvas.getContext('2d') as CanvasRenderingContext2D;\r\n\r\n    const update = () :void => {\r\n        const grid = runCellularAutomaton(\r\n            75, 75,\r\n            parseInt(seedSlider.value),\r\n            parseFloat(popSlider.value),\r\n            5, 4,\r\n            parseInt(genSlider.value)\r\n        );\r\n\r\n        GridTool.forEach(grid, (x, y, val) => {\r\n            ctx.fillStyle = val ? '#000' : '#FFF';\r\n            ctx.fillRect(4*x, 4*y, 4, 4);\r\n        });\r\n\r\n        const coloredGrid = GridTool.map(grid, (x, y, val) => val ? -1 : 0);\r\n        const bigColor = colorGridRegions(coloredGrid);\r\n\r\n        GridTool.forEach(coloredGrid, (x, y, val) => {\r\n            ctx2.fillStyle = gridColorForNumber(val);\r\n            ctx2.fillRect(4*x, 4*y, 4, 4);\r\n        });\r\n\r\n        const filledMap = GridTool.map(coloredGrid, (x, y, val) => val !== bigColor);\r\n\r\n        GridTool.forEach(filledMap, (x, y, val) => {\r\n            ctx3.fillStyle = val ? '#000' : '#FFF';\r\n            ctx3.fillRect(4*x, 4*y, 4, 4);\r\n        });\r\n\r\n        const edgeMarkedMap = markEdges(filledMap);\r\n\r\n        GridTool.forEach(edgeMarkedMap, (x, y, val) => {\r\n            ctx4.fillStyle = val.kind === 'edge' ? gridColorForNormal(val.normal) : val.kind === 'air' ? '#655' : '#77f';\r\n            ctx4.fillRect(4*x, 4*y, 4, 4);\r\n        });\r\n\r\n    };\r\n\r\n    multibind(\r\n        [popSlider, genSlider, seedSlider],\r\n        ['oninput', 'onchange'],\r\n        update\r\n    );\r\n    update();\r\n};","import { nextRandom01 } from './prng';\r\nimport { WriteGrid, Grid } from './grid';\r\n\r\nconst getNeighborhood = (map: Grid<boolean>, x: number, y: number): number => {\r\n    let result: number = 0;\r\n\r\n    for (let nx = x-1; nx <= x+1; ++nx) {\r\n        for (let ny = y-1; ny <= y+1; ++ny) {\r\n            if (nx == x && ny == y) continue;\r\n            if (nx < 1 || ny < 1 || nx >= map.width-1 || ny >= map.height-1) result++;\r\n            else result += map.at(nx,ny) ? 1 : 0;\r\n        }\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\nexport const runCellularAutomaton = (width: number, height: number, seed: number, population: number, birth: number, survival: number, iterations: number): Grid<boolean> => {\r\n    const result = new WriteGrid<boolean>(width, height);\r\n    const buffer = new WriteGrid<boolean>(width, height);\r\n    let rand = nextRandom01(seed / 101);\r\n\r\n    for (let x = 0; x < width; ++x) {\r\n        for (let y = 0; y < height; ++y) {\r\n            const fill = x === 0 || y === 0 || x === width-1 || y === height-1 || rand < population;\r\n            result.write(x, y, fill);\r\n            buffer.write(x, y, fill);\r\n\r\n            rand = nextRandom01(rand);\r\n        }\r\n    }\r\n\r\n    for (let i = 0; i < iterations; ++i) {\r\n        for (let x = 1; x < width-1; ++x) {\r\n            for (let y = 1; y < height-1; ++y) {\r\n                const neighbors = getNeighborhood(result, x, y);\r\n                buffer.write(x, y, neighbors >= (result.at(x, y) ? survival : birth));\r\n            }\r\n        }\r\n        result.copyFrom(buffer);\r\n    }\r\n\r\n    return result;\r\n}","// https://en.wikipedia.org/wiki/Linear_congruential_generator\r\n\r\nconst M = 4294967296;\r\nconst A = 1664525;\r\nconst C = 1013904223;\r\n\r\nexport const nextRandom01 = (prevRandom01: number): number => \r\n    ((A * Math.floor(prevRandom01 * M) + C) % M) / M;","import { Grid, WriteGrid, GridTool } from './grid';\r\n\r\nexport interface EdgeMarkedMapTile {\r\n    kind: 'air' | 'dirt' | 'edge',\r\n    normal: number,\r\n}\r\n\r\nexport const markEdges = (grid: Grid<boolean>): WriteGrid<EdgeMarkedMapTile> => {\r\n    const result = GridTool.map(grid, (x, y, val): EdgeMarkedMapTile => \r\n        ({ kind: val ? 'dirt' : 'air', normal: 0 }));\r\n\r\n    for (let x = 0; x < grid.width; x++) {\r\n        for (let y = 0; y < grid.height; y++) {\r\n            if (!grid.at(x, y)) continue;\r\n\r\n            const l = x > 0               && !grid.at(x-1, y);\r\n            const r = x < grid.width - 2  && !grid.at(x+1, y);\r\n            const u = y > 0               && !grid.at(x, y-1);\r\n            const d = y < grid.height - 2 && !grid.at(x, y+1);\r\n\r\n            if (!l && !r && !u && !d) continue;\r\n\r\n            const normal = r && d ? 45 :\r\n                d && l ?  135 :\r\n                l && u ? -135 :\r\n                u && r ?  -45 :\r\n                r ? 0 :\r\n                d ? 90 :\r\n                l ? 180 :\r\n                -90;\r\n\r\n            result.write(x, y, { kind: 'edge', normal });\r\n        }\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\n// @ts-ignore\r\nenum WalkedStatus {\r\n    Unwalked,\r\n    Walked,\r\n    WalkedImportant,\r\n}\r\n\r\n// @ts-ignore\r\ninterface WalkCandidate {\r\n    dx: number,\r\n    dy: number,\r\n    normal: number,\r\n}\r\n\r\n// @ts-ignore\r\ninterface GridPoint {\r\n    x: number,\r\n    y: number,\r\n}\r\n\r\n    /*\r\n\r\npublic class FindContours\r\n    {\r\n        public enum WalkedStatus {\r\n            Unwalked,\r\n            Walked,\r\n            WalkedImportant,\r\n        }\r\n\r\n        struct WalkCandidate {\r\n            public int dx, dy, normal;\r\n        }\r\n\r\n        struct FreshStart {\r\n            public int x, y;\r\n        }\r\n\r\n        public Vector3[][] Contours { get; private set; }\r\n        public WalkedStatus[,] WalkMap { get; private set; }\r\n\r\n        public FindContours(PixelMap map, int spaceInsurance = 2)\r\n        {\r\n            const int MAX_ITER = 100;\r\n\r\n            var walkMap = new WalkedStatus[map.width, map.height];\r\n            var contours = new List<Vector3[]>();\r\n\r\n            int iter = 0;\r\n            Vector3[] newContour;\r\n\r\n            do {\r\n                newContour = findOneContour(walkMap, map, spaceInsurance);\r\n                if (newContour != null && newContour.Length > 2) {\r\n                    contours.Add(newContour);\r\n                }\r\n            } while (newContour != null && iter++ < MAX_ITER);\r\n\r\n            Contours = contours.ToArray();\r\n            WalkMap = walkMap;\r\n        }\r\n\r\n        static FreshStart? findFreshContour(WalkedStatus[,] walkMap, PixelMap map)\r\n        {\r\n            for (var x = 0; x < map.width; x++) {\r\n                for (var y = 0; y < map.height; y++) {\r\n                    if (map[x,y].kind == PixelKind.Edge && walkMap[x,y] == WalkedStatus.Unwalked) {\r\n                        return new FreshStart { x = x, y = y };\r\n                    }\r\n                }\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n        // spaceInsurance: increased value spreads out contour control points. 0, 1, or 2\r\n        static Vector3[] findOneContour(WalkedStatus[,] walkMap, PixelMap map, int spaceInsurance = 2)\r\n        {\r\n            const int MAX_ITER = 5000;\r\n\r\n            var freshStart = findFreshContour(walkMap, map);\r\n            if (!freshStart.HasValue) {\r\n                return null;\r\n            }\r\n\r\n            var points = new List<Vector3>();\r\n\r\n            var x = freshStart.Value.x;\r\n            var y = freshStart.Value.y;\r\n\r\n            var iter = 0;\r\n            var lastCan = new WalkCandidate { dx=0, dy=0, normal=0 };\r\n            var lastStatus = WalkedStatus.Walked;\r\n            var candidates = new List<WalkCandidate>();\r\n\r\n            do {\r\n                candidates.Clear();\r\n\r\n                for (var dx = -1; dx <= 1; dx++) {\r\n                    for (var dy = -1; dy <= 1; dy++) {\r\n                        if (dx == 0 && dy == 0) continue;\r\n                        if (map[x+dx,y+dy].kind == PixelKind.Edge\r\n                        && walkMap[x+dx,y+dy] == WalkedStatus.Unwalked) {\r\n                            candidates.Add(new WalkCandidate {dx=dx, dy=dy, normal=map[x+dx,y+dy].normal});\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (candidates.Count > 0) {\r\n                    var c = bestCandidate(lastCan, candidates);\r\n                    x += c.dx;\r\n                    y += c.dy;\r\n\r\n                    var newStatus = WalkedStatus.Walked;\r\n                    if (c.normal != lastCan.normal) {\r\n                        bool important;\r\n                        if (spaceInsurance <= 0) {\r\n                            important = true;\r\n                        } else if (spaceInsurance == 1) {\r\n                            important = c.dx != 0 && c.dy != 0 || lastStatus != WalkedStatus.WalkedImportant;\r\n                        } else { // spaceInsurance >= 2\r\n                            important = lastStatus != WalkedStatus.WalkedImportant;\r\n                        }\r\n                        if (important) {\r\n                            newStatus = WalkedStatus.WalkedImportant;\r\n                        }\r\n                    }\r\n\r\n                    if (newStatus == WalkedStatus.WalkedImportant) {\r\n                        points.Add(new Vector3((float)x/map.width - .5f, (float)y/map.height - .5f, -1f));\r\n                    }\r\n\r\n                    walkMap[x,y] = newStatus;\r\n                    lastStatus = newStatus;\r\n                    lastCan = c;\r\n                }\r\n            }\r\n            while (candidates.Count > 0 && iter++ < MAX_ITER);\r\n\r\n            return points.ToArray();\r\n        }\r\n\r\n        static WalkCandidate bestCandidate(WalkCandidate prev, IList<WalkCandidate> candidates)\r\n        {\r\n            var minVal = 100f;\r\n            var minI = 0;\r\n\r\n            for (int i = 0; i < candidates.Count; ++i) {\r\n                var c = candidates[i];\r\n                var d = Mathf.Abs(Angles.SmallestDifference(\r\n                    c.normal * Mathf.Deg2Rad, prev.normal * Mathf.Deg2Rad\r\n                ));\r\n\r\n                if (d < minVal) {\r\n                    minVal = d;\r\n                    minI = i;\r\n                }\r\n            }\r\n\r\n            return candidates[minI];\r\n        }\r\n    }\r\n\r\n    */"],"sourceRoot":""}